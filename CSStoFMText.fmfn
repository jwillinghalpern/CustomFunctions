/* CSStoFMText ( text )
by Christopher Gauntt, Cordega Solutions, www.cordega.com
solutions@cordega.com

v2.9 DEC 6, 2025	steve_ssh
- accumulate styles as a number (sum of style constants) rather than string to be evaluated.
- calculate font color arithmetically rather than using Evaluate.

v2.8 DEC 5, 2025	Josh Willing
- convert from recursion to While iteration
- support bullet points
- fix condense, extend, titlecase, strikethrough, small-caps
- fix "sticky" text decorations like strikethrough and underline, which would cause all subsequent divs to have that decoration.

v2.7 DEC 5, 2025	Josh Willing
- remove Evaluate call from FontType to avoid evaluating injected malicious code. Thanks to Chris Irvine for pointing out the vulnerability.

v2.6 AUG 22, 2024	Josh Willing
- convert encoded html entities back to characters

v2.5 FEB 15, 2020	steve_ssh
- fix Subscript and Superscript

v2.4 APR 2, 2019	Josh Willing
- add HighlightYellow style detection

v2.3 APR 1, 2019	Josh Willing
- don't confuse background-color and color. Doesn't copy background color yet, but font color is fixed.

v2.2 Mar 26, 2019	Josh Willing
- added support for <br/> tag (including slash)
- reformat function text
- Don't apply transformations if none exists
- Use internal let variables
- remove fontscript reference. FM no longer uses it as of 15: https://fmhelp.filemaker.com/help/15/fmp/en/index.html#page/FMP_Help/textfont.html 

v2.1 May 15, 2010
- Fixed the errors brought up in the comments. Sorry it took so long to get around to it! Thanks to Kevin Frank for spotting the comment, and sending me a fixed version.

v2.0 April 06, 2009
- now includes if statements wrapped around main function in case input text doesn't have any SPAN tags. (Otherwise, part of the beginning of the text gets chopped off)
- simplified conversion of Hex Color to straight color decimal value instead of intermediary RGB.

Description:
This takes CSS styled text and converts it back to FileMaker Pro formatting. 

NOTES:
GetAsCSS does not encode some styles such as DoubleUnderline, so it's not this CF's fault when those don't get converted back to styled text.

*/

If ( PatternCount ( text ; "<span" ) = 0 ; Substitute ( text ; "<br>" ; "¶" ) ;

While ([
	~res = text ;
	~MoreSpansExist = True
];
~MoreSpansExist ;
[
	// Grabs SPAN string
	~SpanStart = Position ( ~res ; "<span" ; 0 ; 1 ) ; 
	~SpanEnd= Position ( ~res ; ">" ; ~SpanStart ; 1 ) +1 ; 
	~Span = Middle ( ~res ; ~SpanStart ; ~SpanEnd - ~SpanStart ) ; 


	// Grabs Full SPAN string between SPAN tags
	~FullSpanStart = Position ( ~res ; "<span" ; 1 ; 1 ) ; 
	~FullSpanEnd = Position ( ~res ; "</span>" ; ~FullSpanStart ; 1 ) + 7 ;
	~FullSpan = Middle ( ~res ; ~FullSpanStart ; ~FullSpanEnd - ~FullSpanStart ) ;


	// Grabs only text between span tags
	~TextStart = Position ( ~FullSpan ; ">" ; 0; 1 )+1 ;
	~TextEnd = Position ( ~FullSpan ; "</span>" ; 0 ; 1 ) ;
	~TextSpan = Middle ( ~FullSpan ; ~TextStart ; ~TextEnd - ~TextStart ) ;

	// swaps out breaks with FileMaker return markers
	~Text = Substitute ( 
		~TextSpan ; 
		["<br>" ; "¶" ];
		["<br/>" ; "¶" ]
	) ;


	// Collects Text Styles
	~SuperscriptSearchString = "vertical-align: text-top" ;
	~SubscriptSearchString = "vertical-align: text-bottom" ;
	~styles = If ( PatternCount ( ~Span ; "Bold" ) = 1 ; Bold ; 0 ) 
	+ If ( PatternCount ( ~Span ; "Italic" ) = 1 ; Italic ; 0 ) 
	+ If ( PatternCount ( ~Span ; "Underline" ) = 1 ; Underline ; 0 ) 
	+ If ( PatternCount ( ~Span ; "letter-spacing: -2px" ) = 1 ; Condense ; 0 ) 
	+ If ( PatternCount ( ~Span ; "letter-spacing: 2px" ) = 1 ; Extend ; 0 ) 
	+ If ( PatternCount ( ~Span ; "text-decoration:line-through" ) = 1 ; Strikethrough ; 0 ) 
	+ If ( PatternCount ( ~Span ; "small-caps" ) = 1 ; SmallCaps ; 0 ) 
	+ If ( PatternCount ( ~Span ; ~SuperscriptSearchString ) = 1 ; Superscript ; 0 ) 
	+ If ( PatternCount ( ~Span ; ~SubscriptSearchString ) = 1 ; Subscript ; 0 ) 
	+ If ( PatternCount ( ~Span ; "Uppercase" ) = 1 ; Uppercase ; 0 ) 
	+ If ( PatternCount ( ~Span ; "Lowercase" ) = 1 ; Lowercase ; 0 ) 
	+ If ( PatternCount ( ~Span ; "capitalize" ) = 1 ; Titlecase ; 0 ) 
	+ If ( PatternCount ( ~Span ; "WordUnderline" ) = 1 ; WordUnderline ; 0 ) 
	+ If ( PatternCount ( ~Span ; "DoubleUnderline" ) = 1 ; DoubleUnderline ; 0 ) 
	+ If ( PatternCount ( ~Span ; "background-color: #FFFF00" ) = 1 ; HighlightYellow ; 0 ) ;

	~hasTextDecoration = Position ( ~Span ; "text-decoration:" ; 1 ; 1 ) <> 0 ;

	// Parses out font size
	~FontSize = If ( 
		PatternCount (~Span ; "font-size") = 0 ; 
		"" ; 
		Let ( [ 
			~SizeStart = Position ( ~Span; "font-size"; 0; 1) ;
			~SizeStop = Position ( ~Span; "px"; ~SizeStart; 1) ; 
			~SizeString = Middle ( ~Span; ~SizeStart ; ~SizeStop - ~SizeStart + 1 )
		]; 
			Filter ( ~SizeString; "0123456789") 
		)
	) ;


	// Adjusts font size for Sub/Super-script
	~FontSize = Case ( 
		PatternCount ( ~Span ; ~SuperscriptSearchString ) + PatternCount ( ~Span ; ~SubscriptSearchString ) = 0 ; 
		~FontSize ;
		~FontSize * 2
	) ;


	// Parses out font-family
	~FontType = If ( 
		PatternCount (~Span ; "font-family") = 0 ; 
		"" ; 
		Let ( [ 
			~FontStart = Position ( ~Span; "font-family"; 0; 1) ;
			~FontStartTrue = Position ( ~Span; "'"; ~FontStart; 1) ;
			~FontStop = Position ( ~Span; "'"; ~FontStart; 2) ;
			// includes surrounding singlequotes
			~Quoted = Middle ( ~Span; ~FontStartTrue ; ~FontStop - ~FontStartTrue + 1 )
		]; 
			// remove the singlequotes (avoid using `Evaluate` to prevent injection attacks)
			Middle ( ~Quoted ; 2 ; Length ( ~Quoted ) - 2 )				
		)
	) ;


	//Converts Font Color
	~FontColor = If ( 
		PatternCount (~Span ; ";color:") = 0 and PatternCount (~Span ; "\"color:") = 0 ; 
		"" ; 
		Let ( [
			_HEX_POSITIONS = "123456789ABCDEF" ;
			~colorStart = Position ( ~Span; "#"; 0; 1) ;
			~colorHex = Middle ( ~Span; ~colorStart + 1 ; 6 ) ;
			~HexClean = Trim ( Filter ( Upper ( ~colorHex ) ; "0" & _HEX_POSITIONS ) ) ;
			~R = 16 * Position( _HEX_POSITIONS ; Middle( ~HexClean ; 1 ; 1 ) ; 1 ; 1) + Position( _HEX_POSITIONS ; Middle( ~HexClean ; 2 ; 1 ) ; 1 ; 1);
			~G = 16 * Position( _HEX_POSITIONS ; Middle( ~HexClean ; 3 ; 1 ) ; 1 ; 1) + Position( _HEX_POSITIONS ; Middle( ~HexClean ; 4 ; 1 ) ; 1 ; 1);
			~B = 16 * Position( _HEX_POSITIONS ; Middle( ~HexClean ; 5 ; 1 ) ; 1 ; 1) + Position( _HEX_POSITIONS ; Middle( ~HexClean ; 6 ; 1 ) ; 1 ; 1 )
		];
			RGB( ~R ; ~G ; ~B )
		)
	) ;


	// converts the text string between the span tags into the filemaker conversions from the above
	~ConvertedText = If ( ~styles = 0 ; ~Text ; TextStyleAdd ( ~Text ; ~styles ) ) ;
	~ConvertedText = If ( IsEmpty ( ~FontSize ) ; ~ConvertedText ; TextSize ( ~ConvertedText ; ~FontSize ) ) ;
	~ConvertedText = If ( IsEmpty ( ~FontType ) ; ~ConvertedText ; TextFont ( ~ConvertedText ; ~FontType ) ) ;
	~ConvertedText = If ( IsEmpty ( ~FontColor ) ; ~ConvertedText ; TextColor ( ~ConvertedText ; ~FontColor ) ) ;
	// text decorations like strikethrough and underline seem to be "sticky", so expicitly unset them by appending a style-less span after
	~ConvertedText = If ( ~hasTextDecoration ; ~ConvertedText & "<span style=\"\" ></span>" ; ~ConvertedText ) ;


	// replaces the span string with the converted string.
	~res = Substitute ( ~res ; ~FullSpan ; ~ConvertedText ) ;

	~MoreSpansExist = Position ( ~res ; "<span" ; 0 ; 1 ) <> 0

];

	Substitute ( ~res ;
		[ "&amp;" ; "&" ] ;
		[ "&lt;" ; "<" ] ;
		[ "&gt;" ; ">" ] ;
		[ "&quot;" ; "\"" ] ;
		[ "&apos;" ; "'" ] ; // it appears getascss doesn't convert this one, but it doesn't hurt
		[ "&nbsp;" ; Char(160) ] ; // non-breaking space
		[ "&copy;" ; "©" ] ;
		[ "&reg;" ; "®" ] ;
		[ "&mdash;" ; Char(8212) ] ;
		[ "&ndash;" ; Char(8211) ] ;
		[ "&euro;" ; "€" ] ;
		[ "&pound;" ; "£" ] ;
		[ "&cent;" ; "¢" ] ;
		[ "&deg;" ; "°" ] ;
		[ "&bull;" ; "•" ]
	)

) // End While

) // End If
